From 577396e57abf6b55c54b8ff2ce71895da15604d8 Mon Sep 17 00:00:00 2001
From: qianlongxu <qianlongxu@gmail.com>
Date: Tue, 8 Aug 2023 14:41:24 +0800
Subject: [PATCH] restore ijk custom protocols

---
 libavcodec/Makefile      |   1 +
 libavformat/Makefile     |   9 ++
 libavformat/allformats.c |   3 +
 libavformat/async.c      |   2 +-
 libavformat/avformat.h   |   5 +
 libavformat/demux.c      |  12 +++
 libavformat/ijkutils.c   |  98 ++++++++++++++++++
 libavformat/protocols.c  |   7 ++
 libavutil/Makefile       |   3 +
 libavutil/application.c  | 215 +++++++++++++++++++++++++++++++++++++++
 libavutil/application.h  | 122 ++++++++++++++++++++++
 11 files changed, 476 insertions(+), 1 deletion(-)
 create mode 100644 libavformat/ijkutils.c
 create mode 100644 libavutil/application.c
 create mode 100644 libavutil/application.h

diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 457ec58..81f2d80 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -26,6 +26,7 @@ HEADERS = ac3_parser.h                                                  \
           videotoolbox.h                                                \
           vorbis_parser.h                                               \
           xvmc.h                                                        \
+          packet_internal.h                                             \
 
 OBJS = ac3_parser.o                                                     \
        adts_parser.o                                                    \
diff --git a/libavformat/Makefile b/libavformat/Makefile
index 6c6b779..dfbed75 100644
--- a/libavformat/Makefile
+++ b/libavformat/Makefile
@@ -5,6 +5,14 @@ HEADERS = avformat.h                                                    \
           avio.h                                                        \
           version.h                                                     \
           version_major.h                                               \
+		  avc.h                                                         \
+          url.h                                                         \
+          internal.h                                                    \
+          avio_internal.h                                               \
+          flv.h                                                         \
+          id3v2.h                                                       \
+          os_support.h                                                  \
+          metadata.h                                                    \
 
 OBJS = allformats.o         \
        avformat.o           \
@@ -29,6 +37,7 @@ OBJS = allformats.o         \
        url.o                \
        utils.o              \
        version.o            \
+       ijkutils.o           \
 
 OBJS-$(HAVE_LIBC_MSVCRT)                 += file_open.o
 
diff --git a/libavformat/allformats.c b/libavformat/allformats.c
index 32698b8..17014e5 100644
--- a/libavformat/allformats.c
+++ b/libavformat/allformats.c
@@ -544,6 +544,9 @@ extern const AVInputFormat  ff_libmodplug_demuxer;
 extern const AVInputFormat  ff_libopenmpt_demuxer;
 extern const AVInputFormat  ff_vapoursynth_demuxer;
 
+extern AVInputFormat  ff_ijklivehook_demuxer;
+extern AVInputFormat  ff_ijklas_demuxer;
+
 #include "libavformat/muxer_list.c"
 #include "libavformat/demuxer_list.c"
 
diff --git a/libavformat/async.c b/libavformat/async.c
index 3c6f89c..8c35dd0 100644
--- a/libavformat/async.c
+++ b/libavformat/async.c
@@ -487,7 +487,7 @@ static const AVClass async_context_class = {
     .version    = LIBAVUTIL_VERSION_INT,
 };
 
-const URLProtocol ff_async_protocol = {
+URLProtocol ff_async_protocol = {
     .name                = "async",
     .url_open2           = async_open,
     .url_read            = async_read,
diff --git a/libavformat/avformat.h b/libavformat/avformat.h
index f12fa7d..f403aa7 100644
--- a/libavformat/avformat.h
+++ b/libavformat/avformat.h
@@ -728,6 +728,11 @@ typedef struct AVInputFormat {
      */
     int (*read_header)(struct AVFormatContext *);
 
+    /**
+     * Used by format which open further nested input.
+     */
+    int (*read_header2)(struct AVFormatContext *, AVDictionary **options);
+
     /**
      * Read one packet and put it in 'pkt'. pts and flags are also
      * set. 'avformat_new_stream' can be called only if the flag
diff --git a/libavformat/demux.c b/libavformat/demux.c
index d518515..bccd5a5 100644
--- a/libavformat/demux.c
+++ b/libavformat/demux.c
@@ -226,6 +226,7 @@ int avformat_open_input(AVFormatContext **ps, const char *filename,
     AVFormatContext *s = *ps;
     FFFormatContext *si;
     AVDictionary *tmp = NULL;
+    AVDictionary *tmp2 = NULL;
     ID3v2ExtraMeta *id3v2_extra_meta = NULL;
     int ret = 0;
 
@@ -309,6 +310,15 @@ int avformat_open_input(AVFormatContext **ps, const char *filename,
     if (s->pb)
         ff_id3v2_read_dict(s->pb, &si->id3v2_meta, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta);
 
+    if (s->iformat->read_header2) {
+        if (options)
+            av_dict_copy(&tmp2,*options, 0);
+        if ((ret = s->iformat->read_header2(s, &tmp2)) < 0) {
+            if (s->iformat->flags_internal & FF_FMT_INIT_CLEANUP)
+                goto close;
+            goto fail;
+        }
+    }
     if (s->iformat->read_header)
         if ((ret = s->iformat->read_header(s)) < 0) {
             if (s->iformat->flags_internal & FF_FMT_INIT_CLEANUP)
@@ -362,6 +372,7 @@ int avformat_open_input(AVFormatContext **ps, const char *filename,
     if (options) {
         av_dict_free(options);
         *options = tmp;
+        av_dict_free(&tmp2);
     }
     *ps = s;
     return 0;
@@ -372,6 +383,7 @@ close:
 fail:
     ff_id3v2_free_extra_meta(&id3v2_extra_meta);
     av_dict_free(&tmp);
+    av_dict_free(&tmp2);
     if (s->pb && !(s->flags & AVFMT_FLAG_CUSTOM_IO))
         avio_closep(&s->pb);
     avformat_free_context(s);
diff --git a/libavformat/ijkutils.c b/libavformat/ijkutils.c
new file mode 100644
index 0000000..c6d0134
--- /dev/null
+++ b/libavformat/ijkutils.c
@@ -0,0 +1,98 @@
+/*
+ * utils.c
+ *
+ * Copyright (c) 2003 Fabrice Bellard
+ * Copyright (c) 2013 Zhang Rui <bbcallen@gmail.com>
+ *
+ * This file is part of ijkPlayer.
+ *
+ * ijkPlayer is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * ijkPlayer is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with ijkPlayer; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdlib.h>
+#include "url.h"
+#include "avformat.h"
+
+
+#define IJK_FF_PROTOCOL(x)                                                                          \
+extern URLProtocol ff_##x##_protocol;                                                               \
+int ijkav_register_##x##_protocol(URLProtocol *protocol, int protocol_size);                        \
+int ijkav_register_##x##_protocol(URLProtocol *protocol, int protocol_size)                         \
+{                                                                                                   \
+    if (protocol_size != sizeof(URLProtocol)) {                                                     \
+        av_log(NULL, AV_LOG_ERROR, "ijkav_register_##x##_protocol: ABI mismatch.\n");               \
+        return -1;                                                                                  \
+    }                                                                                               \
+    memcpy(&ff_##x##_protocol, protocol, protocol_size);                                            \
+    return 0;                                                                                       \
+}
+
+#define IJK_DUMMY_PROTOCOL(x)                                       \
+IJK_FF_PROTOCOL(x);                                                 \
+static const AVClass ijk_##x##_context_class = {                    \
+    .class_name = #x,                                               \
+    .item_name  = av_default_item_name,                             \
+    .version    = LIBAVUTIL_VERSION_INT,                            \
+    };                                                              \
+                                                                    \
+URLProtocol ff_##x##_protocol = {                                   \
+    .name                = #x,                                      \
+    .url_open2           = ijkdummy_open,                           \
+    .priv_data_size      = 1,                                       \
+    .priv_data_class     = &ijk_##x##_context_class,                \
+};
+
+static int ijkdummy_open(URLContext *h, const char *arg, int flags, AVDictionary **options)
+{
+    return -1;
+}
+
+IJK_FF_PROTOCOL(async);
+IJK_DUMMY_PROTOCOL(ijkmediadatasource);
+IJK_DUMMY_PROTOCOL(ijkhttphook);
+IJK_DUMMY_PROTOCOL(ijklongurl);
+IJK_DUMMY_PROTOCOL(ijksegment);
+IJK_DUMMY_PROTOCOL(ijktcphook);
+IJK_DUMMY_PROTOCOL(ijkio);
+
+#define IJK_FF_DEMUXER(x)                                                                          \
+extern AVInputFormat ff_##x##_demuxer;                                                               \
+int ijkav_register_##x##_demuxer(AVInputFormat *demuxer, int demuxer_size);                        \
+int ijkav_register_##x##_demuxer(AVInputFormat *demuxer, int demuxer_size)                         \
+{                                                                                                   \
+    if (demuxer_size != sizeof(AVInputFormat)) {                                                     \
+        av_log(NULL, AV_LOG_ERROR, "ijkav_register_##x##_demuxer: ABI mismatch.\n");               \
+        return -1;                                                                                  \
+    }                                                                                               \
+    memcpy(&ff_##x##_demuxer, demuxer, demuxer_size);                                            \
+    return 0;                                                                                       \
+}
+
+#define IJK_DUMMY_DEMUXER(x)                                        \
+IJK_FF_DEMUXER(x);                                                  \
+static const AVClass ijk_##x##_demuxer_class = {                    \
+    .class_name = #x,                                               \
+    .item_name  = av_default_item_name,                             \
+    .version    = LIBAVUTIL_VERSION_INT,                            \
+    };                                                              \
+                                                                    \
+AVInputFormat ff_##x##_demuxer = {                                  \
+    .name                = #x,                                      \
+    .priv_data_size      = 1,                                       \
+    .priv_class          = &ijk_##x##_demuxer_class,                \
+};
+
+IJK_DUMMY_DEMUXER(ijklivehook);
+IJK_DUMMY_DEMUXER(ijklas);
diff --git a/libavformat/protocols.c b/libavformat/protocols.c
index 6ee62a5..5e97b89 100644
--- a/libavformat/protocols.c
+++ b/libavformat/protocols.c
@@ -74,6 +74,13 @@ extern const URLProtocol ff_libzmq_protocol;
 extern const URLProtocol ff_ipfs_protocol;
 extern const URLProtocol ff_ipns_protocol;
 
+extern const URLProtocol ff_ijkhttphook_protocol;
+extern const URLProtocol ff_ijklongurl_protocol;
+extern const URLProtocol ff_ijkmediadatasource_protocol;
+extern const URLProtocol ff_ijksegment_protocol;
+extern const URLProtocol ff_ijktcphook_protocol;
+extern const URLProtocol ff_ijkio_protocol;
+
 #include "libavformat/protocol_list.c"
 
 const AVClass *ff_urlcontext_child_class_iterate(void **iter)
diff --git a/libavutil/Makefile b/libavutil/Makefile
index 9435a0b..986627c 100644
--- a/libavutil/Makefile
+++ b/libavutil/Makefile
@@ -9,6 +9,8 @@ HEADERS = adler32.h                                                     \
           avassert.h                                                    \
           avstring.h                                                    \
           avutil.h                                                      \
+		  application.h                                                 \
+		  thread.h                                                      \
           base64.h                                                      \
           blowfish.h                                                    \
           bprint.h                                                      \
@@ -105,6 +107,7 @@ OBJS = adler32.o                                                        \
        audio_fifo.o                                                     \
        avstring.o                                                       \
        avsscanf.o                                                       \
+	   application.o                                                    \
        base64.o                                                         \
        blowfish.o                                                       \
        bprint.o                                                         \
diff --git a/libavutil/application.c b/libavutil/application.c
new file mode 100644
index 0000000..ec7c1f0
--- /dev/null
+++ b/libavutil/application.c
@@ -0,0 +1,215 @@
+/*
+ * copyright (c) 2016 Zhang Rui
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "application.h"
+#include "../libavformat/network.h"
+#include "avstring.h"
+#include "mem.h"
+
+void av_application_on_io_traffic(AVApplicationContext *h, AVAppIOTraffic *event);
+
+int av_application_alloc(AVApplicationContext **ph, void *opaque)
+{
+    AVApplicationContext *h = NULL;
+
+    h = av_mallocz(sizeof(AVApplicationContext));
+    if (!h)
+        return AVERROR(ENOMEM);
+
+    h->opaque = opaque;
+
+    *ph = h;
+    return 0;
+}
+
+int av_application_open(AVApplicationContext **ph, void *opaque)
+{
+    int ret = av_application_alloc(ph, opaque);
+    if (ret)
+        return ret;
+
+    return 0;
+}
+
+void av_application_close(AVApplicationContext *h)
+{
+    av_free(h);
+}
+
+void av_application_closep(AVApplicationContext **ph)
+{
+    if (!ph || !*ph)
+        return;
+
+    av_application_close(*ph);
+    *ph = NULL;
+}
+
+void av_application_on_http_event(AVApplicationContext *h, int event_type, AVAppHttpEvent *event)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, event_type, (void *)event, sizeof(AVAppHttpEvent));
+}
+
+void av_application_will_http_open(AVApplicationContext *h, void *obj, const char *url)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    av_strlcpy(event.url, url, sizeof(event.url));
+
+    av_application_on_http_event(h, AVAPP_EVENT_WILL_HTTP_OPEN, &event);
+}
+
+void av_application_did_http_open(AVApplicationContext *h, void *obj, const char *url, int error, int http_code, int64_t filesize)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    av_strlcpy(event.url, url, sizeof(event.url));
+    event.error     = error;
+    event.http_code = http_code;
+    event.filesize  = filesize;
+
+    av_application_on_http_event(h, AVAPP_EVENT_DID_HTTP_OPEN, &event);
+}
+
+void av_application_will_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    event.offset     = offset;
+    av_strlcpy(event.url, url, sizeof(event.url));
+
+    av_application_on_http_event(h, AVAPP_EVENT_WILL_HTTP_SEEK, &event);
+}
+
+void av_application_did_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset, int error, int http_code)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    event.offset     = offset;
+    av_strlcpy(event.url, url, sizeof(event.url));
+    event.error     = error;
+    event.http_code = http_code;
+
+    av_application_on_http_event(h, AVAPP_EVENT_DID_HTTP_SEEK, &event);
+}
+
+void av_application_on_io_traffic(AVApplicationContext *h, AVAppIOTraffic *event)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, AVAPP_EVENT_IO_TRAFFIC, (void *)event, sizeof(AVAppIOTraffic));
+}
+
+int  av_application_on_io_control(AVApplicationContext *h, int event_type, AVAppIOControl *control)
+{
+    if (h && h->func_on_app_event)
+        return h->func_on_app_event(h, event_type, (void *)control, sizeof(AVAppIOControl));
+    return 0;
+}
+
+int av_application_on_tcp_will_open(AVApplicationContext *h)
+{
+    if (h && h->func_on_app_event) {
+        AVAppTcpIOControl control = {0};
+        return h->func_on_app_event(h, AVAPP_CTRL_WILL_TCP_OPEN, (void *)&control, sizeof(AVAppTcpIOControl));
+    }
+    return 0;
+}
+
+// only callback returns error
+int av_application_on_tcp_did_open(AVApplicationContext *h, int error, int fd, AVAppTcpIOControl *control)
+{
+    struct sockaddr_storage so_stg;
+    int       ret = 0;
+    socklen_t so_len = sizeof(so_stg);
+    int       so_family;
+    char      *so_ip_name = control->ip;
+
+    if (!h || !h->func_on_app_event || fd <= 0)
+        return 0;
+
+    ret = getpeername(fd, (struct sockaddr *)&so_stg, &so_len);
+    if (ret)
+        return 0;
+    control->error = error;
+    control->fd = fd;
+
+    so_family = ((struct sockaddr*)&so_stg)->sa_family;
+    switch (so_family) {
+        case AF_INET: {
+            struct sockaddr_in* in4 = (struct sockaddr_in*)&so_stg;
+            if (inet_ntop(AF_INET, &(in4->sin_addr), so_ip_name, sizeof(control->ip))) {
+                control->family = AF_INET;
+                control->port = in4->sin_port;
+            }
+            break;
+        }
+        case AF_INET6: {
+            struct sockaddr_in6* in6 = (struct sockaddr_in6*)&so_stg;
+            if (inet_ntop(AF_INET6, &(in6->sin6_addr), so_ip_name, sizeof(control->ip))) {
+                control->family = AF_INET6;
+                control->port = in6->sin6_port;
+            }
+            break;
+        }
+    }
+
+    return h->func_on_app_event(h, AVAPP_CTRL_DID_TCP_OPEN, (void *)control, sizeof(AVAppTcpIOControl));
+}
+
+void av_application_on_async_statistic(AVApplicationContext *h, AVAppAsyncStatistic *statistic)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, AVAPP_EVENT_ASYNC_STATISTIC, (void *)statistic, sizeof(AVAppAsyncStatistic));
+}
+
+void av_application_on_async_read_speed(AVApplicationContext *h, AVAppAsyncReadSpeed *speed)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, AVAPP_EVENT_ASYNC_READ_SPEED, (void *)speed, sizeof(AVAppAsyncReadSpeed));
+}
+
+void av_application_did_io_tcp_read(AVApplicationContext *h, void *obj, int bytes)
+{
+    AVAppIOTraffic event = {0};
+    if (!h || !obj || bytes <= 0)
+        return;
+
+    event.obj        = obj;
+    event.bytes      = bytes;
+
+    av_application_on_io_traffic(h, &event);
+}
diff --git a/libavutil/application.h b/libavutil/application.h
new file mode 100644
index 0000000..b64cb39
--- /dev/null
+++ b/libavutil/application.h
@@ -0,0 +1,122 @@
+/*
+ * copyright (c) 2016 Zhang Rui
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_APPLICATION_H
+#define AVUTIL_APPLICATION_H
+
+#include <stdio.h>
+#include "libavutil/log.h"
+
+#define AVAPP_EVENT_WILL_HTTP_OPEN  1 //AVAppHttpEvent
+#define AVAPP_EVENT_DID_HTTP_OPEN   2 //AVAppHttpEvent
+#define AVAPP_EVENT_WILL_HTTP_SEEK  3 //AVAppHttpEvent
+#define AVAPP_EVENT_DID_HTTP_SEEK   4 //AVAppHttpEvent
+
+#define AVAPP_EVENT_ASYNC_STATISTIC     0x11000 //AVAppAsyncStatistic
+#define AVAPP_EVENT_ASYNC_READ_SPEED    0x11001 //AVAppAsyncReadSpeed
+#define AVAPP_EVENT_IO_TRAFFIC          0x12204 //AVAppIOTraffic
+
+#define AVAPP_CTRL_WILL_TCP_OPEN   0x20001 //AVAppTcpIOControl
+#define AVAPP_CTRL_DID_TCP_OPEN    0x20002 //AVAppTcpIOControl
+
+#define AVAPP_CTRL_WILL_HTTP_OPEN  0x20003 //AVAppIOControl
+#define AVAPP_CTRL_WILL_LIVE_OPEN  0x20005 //AVAppIOControl
+
+#define AVAPP_CTRL_WILL_CONCAT_SEGMENT_OPEN 0x20007 //AVAppIOControl
+
+typedef struct AVAppIOControl {
+    size_t  size;
+    char    url[4096];      /* in, out */
+    int     segment_index;  /* in, default = 0 */
+    int     retry_counter;  /* in */
+
+    int     is_handled;     /* out, default = false */
+    int     is_url_changed; /* out, default = false */
+} AVAppIOControl;
+
+typedef struct AVAppTcpIOControl {
+    int  error;
+    int  family;
+    char ip[96];
+    int  port;
+    int  fd;
+} AVAppTcpIOControl;
+
+typedef struct AVAppAsyncStatistic {
+    size_t  size;
+    int64_t buf_backwards;
+    int64_t buf_forwards;
+    int64_t buf_capacity;
+} AVAppAsyncStatistic;
+
+typedef struct AVAppAsyncReadSpeed {
+    size_t  size;
+    int     is_full_speed;
+    int64_t io_bytes;
+    int64_t elapsed_milli;
+} AVAppAsyncReadSpeed;
+
+typedef struct AVAppHttpEvent
+{
+    void    *obj;
+    char     url[4096];
+    int64_t  offset;
+    int      error;
+    int      http_code;
+    int64_t  filesize;
+} AVAppHttpEvent;
+
+typedef struct AVAppIOTraffic
+{
+    void   *obj;
+    int     bytes;
+} AVAppIOTraffic;
+
+typedef struct AVApplicationContext AVApplicationContext;
+struct AVApplicationContext {
+    const AVClass *av_class;    /**< information for av_log(). Set by av_application_open(). */
+    void *opaque;               /**< user data. */
+
+    int (*func_on_app_event)(AVApplicationContext *h, int event_type ,void *obj, size_t size);
+};
+
+int  av_application_alloc(AVApplicationContext **ph, void *opaque);
+int  av_application_open(AVApplicationContext **ph, void *opaque);
+void av_application_close(AVApplicationContext *h);
+void av_application_closep(AVApplicationContext **ph);
+
+void av_application_on_http_event(AVApplicationContext *h, int event_type, AVAppHttpEvent *event);
+void av_application_will_http_open(AVApplicationContext *h, void *obj, const char *url);
+void av_application_did_http_open(AVApplicationContext *h, void *obj, const char *url, int error, int http_code, int64_t filesize);
+void av_application_will_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset);
+void av_application_did_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset, int error, int http_code);
+
+void av_application_did_io_tcp_read(AVApplicationContext *h, void *obj, int bytes);
+
+int  av_application_on_io_control(AVApplicationContext *h, int event_type, AVAppIOControl *control);
+
+int av_application_on_tcp_will_open(AVApplicationContext *h);
+int av_application_on_tcp_did_open(AVApplicationContext *h, int error, int fd, AVAppTcpIOControl *control);
+
+void av_application_on_async_statistic(AVApplicationContext *h, AVAppAsyncStatistic *statistic);
+void av_application_on_async_read_speed(AVApplicationContext *h, AVAppAsyncReadSpeed *speed);
+
+
+#endif /* AVUTIL_APPLICATION_H */
-- 
2.39.2 (Apple Git-143)

