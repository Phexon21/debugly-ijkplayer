From 391125a7c250b027bded465ca88da11caaee8231 Mon Sep 17 00:00:00 2001
From: qianlongxu <qianlongxu@gmail.com>
Date: Fri, 29 Jul 2022 13:01:01 +0800
Subject: [PATCH 10/16] tcp hook

---
 libavformat/http.c      |  53 +++-
 libavformat/tcp.c       | 599 ++++++++++++++++++++++++++++++++++++++--
 libavformat/utils.c     |  86 +++++-
 libavutil/application.c | 214 ++++++++++++++
 libavutil/application.h | 121 ++++++++
 libavutil/dns_cache.c   | 229 +++++++++++++++
 libavutil/dns_cache.h   |  38 +++
 libavutil/error.h       |   4 +
 8 files changed, 1313 insertions(+), 31 deletions(-)
 create mode 100644 libavutil/application.c
 create mode 100644 libavutil/application.h
 create mode 100644 libavutil/dns_cache.c
 create mode 100644 libavutil/dns_cache.h

diff --git a/libavformat/http.c b/libavformat/http.c
index 4fdb2f1..479591e 100644
--- a/libavformat/http.c
+++ b/libavformat/http.c
@@ -30,6 +30,7 @@
 #include "libavutil/opt.h"
 #include "libavutil/time.h"
 #include "libavutil/parseutils.h"
+#include "libavutil/application.h"
 
 #include "avformat.h"
 #include "http.h"
@@ -125,6 +126,9 @@ typedef struct HTTPContext {
     int is_multi_client;
     HandshakeState handshake_step;
     int is_connected_server;
+    char *tcp_hook;
+    char * app_ctx_intptr;
+    AVApplicationContext *app_ctx;
 } HTTPContext;
 
 #define OFFSET(x) offsetof(HTTPContext, x)
@@ -167,6 +171,8 @@ static const AVOption options[] = {
     { "listen", "listen on HTTP", OFFSET(listen), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 2, D | E },
     { "resource", "The resource requested by a client", OFFSET(resource), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, E },
     { "reply_code", "The http status code to return to a client", OFFSET(reply_code), AV_OPT_TYPE_INT, { .i64 = 200}, INT_MIN, 599, E},
+    { "http-tcp-hook", "hook protocol on tcp", OFFSET(tcp_hook), AV_OPT_TYPE_STRING, { .str = "tcp" }, 0, 0, D | E },
+    { "ijkapplication", "AVApplicationContext", OFFSET(app_ctx_intptr), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, .flags = D },
     { NULL }
 };
 
@@ -194,8 +200,11 @@ static int http_open_cnx_internal(URLContext *h, AVDictionary **options)
     char path1[MAX_URL_SIZE];
     char buf[1024], urlbuf[MAX_URL_SIZE];
     int port, use_proxy, err, location_changed = 0;
+    char prev_location[4096];
     HTTPContext *s = h->priv_data;
 
+    lower_proto = s->tcp_hook;
+
     av_url_split(proto, sizeof(proto), auth, sizeof(auth),
                  hostname, sizeof(hostname), &port,
                  path1, sizeof(path1), s->location);
@@ -206,6 +215,7 @@ static int http_open_cnx_internal(URLContext *h, AVDictionary **options)
                  proxy_path && av_strstart(proxy_path, "http://", NULL);
 
     if (!strcmp(proto, "https")) {
+        av_dict_set_int(options, "fastopen", 0, 0);
         lower_proto = "tls";
         use_proxy   = 0;
         if (port < 0)
@@ -232,6 +242,7 @@ static int http_open_cnx_internal(URLContext *h, AVDictionary **options)
     ff_url_join(buf, sizeof(buf), lower_proto, NULL, hostname, port, NULL);
 
     if (!s->hd) {
+        av_dict_set_intptr(options, "ijkapplication", (uintptr_t)s->app_ctx, 0);
         err = ffurl_open_whitelist(&s->hd, buf, AVIO_FLAG_READ_WRITE,
                                    &h->interrupt_callback, options,
                                    h->protocol_whitelist, h->protocol_blacklist, h);
@@ -239,6 +250,7 @@ static int http_open_cnx_internal(URLContext *h, AVDictionary **options)
             return err;
     }
 
+    av_strlcpy(prev_location, s->location, sizeof(prev_location));
     err = http_connect(h, path, local_path, hoststr,
                        auth, proxyauth, &location_changed);
     if (err < 0)
@@ -525,6 +537,8 @@ static int http_open(URLContext *h, const char *uri, int flags,
     HTTPContext *s = h->priv_data;
     int ret;
 
+    s->app_ctx = (AVApplicationContext *)av_dict_strtoptr(s->app_ctx_intptr);
+
     if( s->seekable == 1 )
         h->is_streamed = 0;
     else
@@ -554,7 +568,9 @@ static int http_open(URLContext *h, const char *uri, int flags,
     if (s->listen) {
         return http_listen(h, uri, flags, options);
     }
+    av_application_will_http_open(s->app_ctx, (void*)h, uri);
     ret = http_open_cnx(h, options);
+    av_application_did_http_open(s->app_ctx, (void*)h, uri, ret, s->http_code, s->filesize);
     if (ret < 0)
         av_dict_free(&s->chained_options);
     return ret;
@@ -1163,6 +1179,7 @@ static int http_connect(URLContext *h, const char *path, const char *local_path,
     char headers[HTTP_HEADERS_SIZE] = "";
     char *authstr = NULL, *proxyauthstr = NULL;
     uint64_t off = s->off;
+    uint64_t filesize = s->filesize;
     int len = 0;
     const char *method;
     int send_expect_100 = 0;
@@ -1330,6 +1347,15 @@ static int http_connect(URLContext *h, const char *path, const char *local_path,
     if (*new_location)
         s->off = off;
 
+    /* Some buggy servers may missing 'Content-Range' header for range request */
+    if (off > 0 && s->off <= 0 && (off + s->filesize == filesize)) {
+        av_log(NULL, AV_LOG_WARNING,
+               "try to fix missing 'Content-Range' at server side (%"PRId64",%"PRId64") => (%"PRId64",%"PRId64")",
+               s->off, s->filesize, off, filesize);
+        s->off = off;
+        s->filesize = filesize;
+    }
+
     err = (off == s->off) ? 0 : -1;
 done:
     av_freep(&authstr);
@@ -1361,16 +1387,8 @@ static int http_buf_read(URLContext *h, uint8_t *buf, int size)
                    "Chunked encoding data size: %"PRIu64"\n",
                     s->chunksize);
 
-            if (!s->chunksize && s->multiple_requests) {
-                http_get_line(s, line, sizeof(line)); // read empty chunk
-                s->chunkend = 1;
+            if (!s->chunksize)
                 return 0;
-            }
-            else if (!s->chunksize) {
-                av_log(h, AV_LOG_DEBUG, "Last chunk received, closing conn\n");
-                ffurl_closep(&s->hd);
-                return 0;
-            }
             else if (s->chunksize == UINT64_MAX) {
                 av_log(h, AV_LOG_ERROR, "Invalid chunk size %"PRIu64"\n",
                        s->chunksize);
@@ -1391,7 +1409,15 @@ static int http_buf_read(URLContext *h, uint8_t *buf, int size)
         uint64_t target_end = s->end_off ? s->end_off : s->filesize;
         if ((!s->willclose || s->chunksize == UINT64_MAX) && s->off >= target_end)
             return AVERROR_EOF;
-        len = ffurl_read(s->hd, buf, size);
+
+        len = size;
+        if (s->filesize > 0 && s->filesize != UINT64_MAX && s->filesize != 2147483647) {
+            int64_t unread = s->filesize - s->off;
+            if (len > unread)
+                len = (int)unread;
+        }
+        if (len > 0)
+            len = ffurl_read(s->hd, buf, len);
         if (!len && (!s->willclose || s->chunksize == UINT64_MAX) && s->off < target_end) {
             av_log(h, AV_LOG_ERROR,
                    "Stream ends prematurely at %"PRIu64", should be %"PRIu64"\n",
@@ -1694,7 +1720,9 @@ static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int fo
     s->hd = NULL;
 
     /* if it fails, continue on old connection */
+    av_application_will_http_seek(s->app_ctx, (void*)h, s->location, off);
     if ((ret = http_open_cnx(h, &options)) < 0) {
+        av_application_did_http_seek(s->app_ctx, (void*)h, s->location, off, ret, s->http_code);
         av_dict_free(&options);
         memcpy(s->buffer, old_buf, old_buf_size);
         s->buf_ptr = s->buffer;
@@ -1703,6 +1731,7 @@ static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int fo
         s->off     = old_off;
         return ret;
     }
+    av_application_did_http_seek(s->app_ctx, (void*)h, s->location, off, ret, s->http_code);
     av_dict_free(&options);
     ffurl_close(old_hd);
     return off;
@@ -1795,6 +1824,8 @@ static int http_proxy_open(URLContext *h, const char *uri, int flags)
     char *authstr;
     int new_loc;
 
+    s->app_ctx = (AVApplicationContext *)av_dict_strtoptr(s->app_ctx_intptr);
+
     if( s->seekable == 1 )
         h->is_streamed = 0;
     else
@@ -1807,7 +1838,7 @@ static int http_proxy_open(URLContext *h, const char *uri, int flags)
     if (*path == '/')
         path++;
 
-    ff_url_join(lower_url, sizeof(lower_url), "tcp", NULL, hostname, port,
+    ff_url_join(lower_url, sizeof(lower_url), s->tcp_hook, NULL, hostname, port,
                 NULL);
 redo:
     ret = ffurl_open_whitelist(&s->hd, lower_url, AVIO_FLAG_READ_WRITE,
diff --git a/libavformat/tcp.c b/libavformat/tcp.c
index 8773493..fc72623 100644
--- a/libavformat/tcp.c
+++ b/libavformat/tcp.c
@@ -23,6 +23,8 @@
 #include "libavutil/parseutils.h"
 #include "libavutil/opt.h"
 #include "libavutil/time.h"
+#include "libavutil/application.h"
+#include "libavutil/dns_cache.h"
 
 #include "internal.h"
 #include "network.h"
@@ -31,6 +33,9 @@
 #if HAVE_POLL_H
 #include <poll.h>
 #endif
+#if HAVE_PTHREADS
+#include <pthread.h>
+#endif
 
 typedef struct TCPContext {
     const AVClass *class;
@@ -42,18 +47,40 @@ typedef struct TCPContext {
     int recv_buffer_size;
     int send_buffer_size;
     int tcp_nodelay;
+    char * app_ctx_intptr;
+
+    int addrinfo_one_by_one;
+    int addrinfo_timeout;
+    int64_t dns_cache_timeout;
+    int dns_cache_clear;
+
+    AVApplicationContext *app_ctx;
+    char uri[1024];
+    int fastopen;
+    int tcp_connected;
+    int fastopen_success;
 } TCPContext;
 
+#define FAST_OPEN_FLAG 0x20000000
+
 #define OFFSET(x) offsetof(TCPContext, x)
 #define D AV_OPT_FLAG_DECODING_PARAM
 #define E AV_OPT_FLAG_ENCODING_PARAM
 static const AVOption options[] = {
     { "listen",          "Listen for incoming connections",  OFFSET(listen),         AV_OPT_TYPE_INT, { .i64 = 0 },     0,       2,       .flags = D|E },
     { "timeout",     "set timeout (in microseconds) of socket I/O operations", OFFSET(rw_timeout),     AV_OPT_TYPE_INT, { .i64 = -1 },         -1, INT_MAX, .flags = D|E },
+    { "connect_timeout",  "set connect timeout (in microseconds) of socket", OFFSET(open_timeout),     AV_OPT_TYPE_INT, { .i64 = -1 },         -1, INT_MAX, .flags = D|E },
     { "listen_timeout",  "Connection awaiting timeout (in milliseconds)",      OFFSET(listen_timeout), AV_OPT_TYPE_INT, { .i64 = -1 },         -1, INT_MAX, .flags = D|E },
     { "send_buffer_size", "Socket send buffer size (in bytes)",                OFFSET(send_buffer_size), AV_OPT_TYPE_INT, { .i64 = -1 },         -1, INT_MAX, .flags = D|E },
     { "recv_buffer_size", "Socket receive buffer size (in bytes)",             OFFSET(recv_buffer_size), AV_OPT_TYPE_INT, { .i64 = -1 },         -1, INT_MAX, .flags = D|E },
     { "tcp_nodelay", "Use TCP_NODELAY to disable nagle's algorithm",           OFFSET(tcp_nodelay), AV_OPT_TYPE_BOOL, { .i64 = 0 },             0, 1, .flags = D|E },
+    { "ijkapplication",   "AVApplicationContext",                              OFFSET(app_ctx_intptr),   AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, .flags = D },
+
+    { "addrinfo_one_by_one",  "parse addrinfo one by one in getaddrinfo()",    OFFSET(addrinfo_one_by_one), AV_OPT_TYPE_INT, { .i64 = 0 },         0, 1, .flags = D|E },
+    { "addrinfo_timeout", "set timeout (in microseconds) for getaddrinfo()",   OFFSET(addrinfo_timeout), AV_OPT_TYPE_INT, { .i64 = -1 },       -1, INT_MAX, .flags = D|E },
+    { "dns_cache_timeout", "dns cache TTL (in microseconds)",   OFFSET(dns_cache_timeout), AV_OPT_TYPE_INT, { .i64 = 0 },       -1, INT64_MAX, .flags = D|E },
+    { "dns_cache_clear", "clear dns cache",   OFFSET(dns_cache_clear), AV_OPT_TYPE_INT, { .i64 = 0},       -1, INT_MAX, .flags = D|E },
+    { "fastopen", "enable fastopen",          OFFSET(fastopen), AV_OPT_TYPE_INT, { .i64 = 0},       0, INT_MAX, .flags = D|E },
     { NULL }
 };
 
@@ -64,6 +91,254 @@ static const AVClass tcp_class = {
     .version    = LIBAVUTIL_VERSION_INT,
 };
 
+int ijk_tcp_getaddrinfo_nonblock(const char *hostname, const char *servname,
+                                 const struct addrinfo *hints, struct addrinfo **res,
+                                 int64_t timeout,
+                                 const AVIOInterruptCB *int_cb, int one_by_one);
+#ifdef HAVE_PTHREADS
+
+typedef struct TCPAddrinfoRequest
+{
+    AVBufferRef *buffer;
+
+    pthread_mutex_t mutex;
+    pthread_cond_t cond;
+
+    AVIOInterruptCB interrupt_callback;
+
+    char            *hostname;
+    char            *servname;
+    struct addrinfo  hints;
+    struct addrinfo *res;
+
+    volatile int     finished;
+    int              last_error;
+} TCPAddrinfoRequest;
+
+static void tcp_getaddrinfo_request_free(TCPAddrinfoRequest *req)
+{
+    av_assert0(req);
+    if (req->res) {
+        freeaddrinfo(req->res);
+        req->res = NULL;
+    }
+
+    av_freep(&req->servname);
+    av_freep(&req->hostname);
+    pthread_cond_destroy(&req->cond);
+    pthread_mutex_destroy(&req->mutex);
+    av_freep(&req);
+}
+
+static void tcp_getaddrinfo_request_free_buffer(void *opaque, uint8_t *data)
+{
+    av_assert0(opaque);
+    TCPAddrinfoRequest *req = (TCPAddrinfoRequest *)opaque;
+    tcp_getaddrinfo_request_free(req);
+}
+
+static int tcp_getaddrinfo_request_create(TCPAddrinfoRequest **request,
+                                          const char *hostname,
+                                          const char *servname,
+                                          const struct addrinfo *hints,
+                                          const AVIOInterruptCB *int_cb)
+{
+    TCPAddrinfoRequest *req = (TCPAddrinfoRequest *) av_mallocz(sizeof(TCPAddrinfoRequest));
+    if (!req)
+        return AVERROR(ENOMEM);
+
+    if (pthread_mutex_init(&req->mutex, NULL)) {
+        av_freep(&req);
+        return AVERROR(ENOMEM);
+    }
+
+    if (pthread_cond_init(&req->cond, NULL)) {
+        pthread_mutex_destroy(&req->mutex);
+        av_freep(&req);
+        return AVERROR(ENOMEM);
+    }
+
+    if (int_cb)
+        req->interrupt_callback = *int_cb;
+
+    if (hostname) {
+        req->hostname = av_strdup(hostname);
+        if (!req->hostname)
+            goto fail;
+    }
+
+    if (servname) {
+        req->servname = av_strdup(servname);
+        if (!req->hostname)
+            goto fail;
+    }
+
+    if (hints) {
+        req->hints.ai_family   = hints->ai_family;
+        req->hints.ai_socktype = hints->ai_socktype;
+        req->hints.ai_protocol = hints->ai_protocol;
+        req->hints.ai_flags    = hints->ai_flags;
+    }
+
+    req->buffer = av_buffer_create(NULL, 0, tcp_getaddrinfo_request_free_buffer, req, 0);
+    if (!req->buffer)
+        goto fail;
+
+    *request = req;
+    return 0;
+fail:
+    tcp_getaddrinfo_request_free(req);
+    return AVERROR(ENOMEM);
+}
+
+static void *tcp_getaddrinfo_worker(void *arg)
+{
+    TCPAddrinfoRequest *req = arg;
+
+    getaddrinfo(req->hostname, req->servname, &req->hints, &req->res);
+    pthread_mutex_lock(&req->mutex);
+    req->finished = 1;
+    pthread_cond_signal(&req->cond);
+    pthread_mutex_unlock(&req->mutex);
+    av_buffer_unref(&req->buffer);
+    return NULL;
+}
+
+static void *tcp_getaddrinfo_one_by_one_worker(void *arg)
+{
+    struct addrinfo *temp_addrinfo = NULL;
+    struct addrinfo *cur = NULL;
+    int ret = EAI_FAIL;
+    int i = 0;
+    int option_length = 0;
+
+    TCPAddrinfoRequest *req = (TCPAddrinfoRequest *)arg;
+
+    int family_option[2] = {AF_INET, AF_INET6};
+
+    option_length = sizeof(family_option) / sizeof(family_option[0]);
+
+    for (; i < option_length; ++i) {
+        struct addrinfo *hint = &req->hints;
+        hint->ai_family = family_option[i];
+        ret = getaddrinfo(req->hostname, req->servname, hint, &temp_addrinfo);
+        if (ret) {
+            req->last_error = ret;
+            continue;
+        }
+        pthread_mutex_lock(&req->mutex);
+        if (!req->res) {
+            req->res = temp_addrinfo;
+        } else {
+            cur = req->res;
+            while (cur->ai_next)
+                cur = cur->ai_next;
+            cur->ai_next = temp_addrinfo;
+        }
+        pthread_mutex_unlock(&req->mutex);
+    }
+    pthread_mutex_lock(&req->mutex);
+    req->finished = 1;
+    pthread_cond_signal(&req->cond);
+    pthread_mutex_unlock(&req->mutex);
+    av_buffer_unref(&req->buffer);
+    return NULL;
+}
+
+int ijk_tcp_getaddrinfo_nonblock(const char *hostname, const char *servname,
+                                 const struct addrinfo *hints, struct addrinfo **res,
+                                 int64_t timeout,
+                                 const AVIOInterruptCB *int_cb, int one_by_one)
+{
+    int     ret;
+    int64_t start;
+    int64_t now;
+    AVBufferRef        *req_ref = NULL;
+    TCPAddrinfoRequest *req     = NULL;
+    pthread_t work_thread;
+
+    if (hostname && !hostname[0])
+        hostname = NULL;
+
+    if (timeout <= 0)
+        return getaddrinfo(hostname, servname, hints, res);
+
+    ret = tcp_getaddrinfo_request_create(&req, hostname, servname, hints, int_cb);
+    if (ret)
+        goto fail;
+
+    req_ref = av_buffer_ref(req->buffer);
+    if (req_ref == NULL) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    /* FIXME: using a thread pool would be better. */
+    if (one_by_one)
+        ret = pthread_create(&work_thread, NULL, tcp_getaddrinfo_one_by_one_worker, req);
+    else
+        ret = pthread_create(&work_thread, NULL, tcp_getaddrinfo_worker, req);
+
+    if (ret) {
+        ret = AVERROR(ret);
+        goto fail;
+    }
+
+    pthread_detach(work_thread);
+
+    start = av_gettime();
+    now   = start;
+
+    pthread_mutex_lock(&req->mutex);
+    while (1) {
+        int64_t wait_time = now + 100000;
+        struct timespec tv = { .tv_sec  =  wait_time / 1000000,
+                               .tv_nsec = (wait_time % 1000000) * 1000 };
+
+        if (req->finished || (start + timeout < now)) {
+            if (req->res) {
+                ret = 0;
+                *res = req->res;
+                req->res = NULL;
+            } else {
+                ret = req->last_error ? req->last_error : AVERROR_EXIT;
+            }
+            break;
+        }
+#if defined(__ANDROID__) && defined(HAVE_PTHREAD_COND_TIMEDWAIT_MONOTONIC)
+        ret = pthread_cond_timedwait_monotonic_np(&req->cond, &req->mutex, &tv);
+#else
+        ret = pthread_cond_timedwait(&req->cond, &req->mutex, &tv);
+#endif
+        if (ret != 0 && ret != ETIMEDOUT) {
+            av_log(NULL, AV_LOG_ERROR, "pthread_cond_timedwait failed: %d\n", ret);
+            ret = AVERROR_EXIT;
+            break;
+        }
+
+        if (ff_check_interrupt(&req->interrupt_callback)) {
+            ret = AVERROR_EXIT;
+            break;
+        }
+
+        now = av_gettime();
+    }
+    pthread_mutex_unlock(&req->mutex);
+fail:
+    av_buffer_unref(&req_ref);
+    return ret;
+}
+
+#else
+int ijk_tcp_getaddrinfo_nonblock(const char *hostname, const char *servname,
+                                 const struct addrinfo *hints, struct addrinfo **res,
+                                 int64_t timeout,
+                                 const AVIOInterruptCB *int_cb)
+{
+    return getaddrinfo(hostname, servname, hints, res);
+}
+#endif
+
 /* return non zero if error */
 static int tcp_open(URLContext *h, const char *uri, int flags)
 {
@@ -75,7 +350,20 @@ static int tcp_open(URLContext *h, const char *uri, int flags)
     int ret;
     char hostname[1024],proto[1024],path[1024];
     char portstr[10];
-    s->open_timeout = 5000000;
+    AVAppTcpIOControl control = {0};
+    DnsCacheEntry *dns_entry = NULL;
+
+    if (s->open_timeout < 0) {
+        s->open_timeout = 15000000;
+    }
+
+    s->app_ctx = (AVApplicationContext *)av_dict_strtoptr(s->app_ctx_intptr);
+
+    if (s->fastopen) {
+        s->tcp_connected = 0;
+        strcpy(s->uri, uri);
+        return 0;
+    }
 
     av_url_split(proto, sizeof(proto), NULL, 0, hostname, sizeof(hostname),
         &port, path, sizeof(path), uri);
@@ -96,32 +384,57 @@ static int tcp_open(URLContext *h, const char *uri, int flags)
         }
         if (av_find_info_tag(buf, sizeof(buf), "timeout", p)) {
             s->rw_timeout = strtol(buf, NULL, 10);
+            if (s->rw_timeout >= 0) {
+                s->open_timeout = s->rw_timeout;
+            }
         }
         if (av_find_info_tag(buf, sizeof(buf), "listen_timeout", p)) {
             s->listen_timeout = strtol(buf, NULL, 10);
         }
     }
-    if (s->rw_timeout >= 0) {
-        s->open_timeout =
-        h->rw_timeout   = s->rw_timeout;
+    if (s->rw_timeout >= 0 ) {
+        h->rw_timeout = s->rw_timeout;
     }
+
     hints.ai_family = AF_UNSPEC;
     hints.ai_socktype = SOCK_STREAM;
     snprintf(portstr, sizeof(portstr), "%d", port);
     if (s->listen)
         hints.ai_flags |= AI_PASSIVE;
-    if (!hostname[0])
-        ret = getaddrinfo(NULL, portstr, &hints, &ai);
-    else
-        ret = getaddrinfo(hostname, portstr, &hints, &ai);
-    if (ret) {
-        av_log(h, AV_LOG_ERROR,
-               "Failed to resolve hostname %s: %s\n",
-               hostname, gai_strerror(ret));
-        return AVERROR(EIO);
+
+    if (s->dns_cache_timeout > 0) {
+        if (s->dns_cache_clear) {
+            av_log(NULL, AV_LOG_INFO, "will delete dns cache entry, uri = %s\n", uri);
+            remove_dns_cache_entry(uri);
+        } else {
+            dns_entry = get_dns_cache_reference(uri);
+        }
     }
 
-    cur_ai = ai;
+    if (!dns_entry) {
+#ifdef HAVE_PTHREADS
+        ret = ijk_tcp_getaddrinfo_nonblock(hostname, portstr, &hints, &ai, s->addrinfo_timeout, &h->interrupt_callback, s->addrinfo_one_by_one);
+#else
+        if (s->addrinfo_timeout > 0)
+            av_log(h, AV_LOG_WARNING, "Ignore addrinfo_timeout without pthreads support.\n");
+        if (!hostname[0])
+            ret = getaddrinfo(NULL, portstr, &hints, &ai);
+        else
+            ret = getaddrinfo(hostname, portstr, &hints, &ai);
+#endif
+
+        if (ret) {
+            av_log(h, AV_LOG_ERROR,
+                "Failed to resolve hostname %s: %s\n",
+                hostname, gai_strerror(ret));
+            return AVERROR(EIO);
+        }
+
+        cur_ai = ai;
+    } else {
+        av_log(NULL, AV_LOG_INFO, "hit dns cache uri = %s\n", uri);
+        cur_ai = dns_entry->res;
+    }
 
  restart:
 #if HAVE_STRUCT_SOCKADDR_IN6
@@ -166,20 +479,233 @@ static int tcp_open(URLContext *h, const char *uri, int flags)
         // Socket descriptor already closed here. Safe to overwrite to client one.
         fd = ret;
     } else {
+        ret = av_application_on_tcp_will_open(s->app_ctx);
+        if (ret) {
+            av_log(NULL, AV_LOG_WARNING, "terminated by application in AVAPP_CTRL_WILL_TCP_OPEN");
+            goto fail1;
+        }
+
         if ((ret = ff_listen_connect(fd, cur_ai->ai_addr, cur_ai->ai_addrlen,
                                      s->open_timeout / 1000, h, !!cur_ai->ai_next)) < 0) {
+            if (ret == AVERROR(ETIMEDOUT)) {
+                ret = AVERROR_TCP_CONNECT_TIMEOUT;
+            }
+            if (av_application_on_tcp_did_open(s->app_ctx, ret, fd, &control))
+                goto fail1;
+            if (ret == AVERROR_EXIT)
+                goto fail1;
+            else
+                goto fail;
+        } else {
+            ret = av_application_on_tcp_did_open(s->app_ctx, 0, fd, &control);
+            if (ret) {
+                av_log(NULL, AV_LOG_WARNING, "terminated by application in AVAPP_CTRL_DID_TCP_OPEN");
+                goto fail1;
+            } else if (!dns_entry && !strstr(uri, control.ip) && s->dns_cache_timeout > 0) {
+                add_dns_cache_entry(uri, cur_ai, s->dns_cache_timeout);
+                av_log(NULL, AV_LOG_INFO, "add dns cache uri = %s, ip = %s\n", uri , control.ip);
+            }
+            av_log(NULL, AV_LOG_INFO, "tcp did open uri = %s, ip = %s\n", uri , control.ip);
+        }
+    }
+
+    h->is_streamed = 1;
+    s->fd = fd;
+
+    if (dns_entry) {
+        release_dns_cache_reference(uri, &dns_entry);
+    } else {
+        freeaddrinfo(ai);
+    }
+    return 0;
+
+ fail:
+    if (cur_ai->ai_next) {
+        /* Retry with the next sockaddr */
+        cur_ai = cur_ai->ai_next;
+        if (fd >= 0)
+            closesocket(fd);
+        ret = 0;
+        goto restart;
+    }
+ fail1:
+    if (fd >= 0)
+        closesocket(fd);
+
+    if (dns_entry) {
+        av_log(NULL, AV_LOG_ERROR, "hit dns cache but connect fail uri = %s, ip = %s\n", uri , control.ip);
+        release_dns_cache_reference(uri, &dns_entry);
+        remove_dns_cache_entry(uri);
+    } else {
+        freeaddrinfo(ai);
+    }
+
+    return ret;
+}
+
+/* return non zero if error */
+static int tcp_fast_open(URLContext *h, const char *http_request, const char *uri, int flags)
+{
+    struct addrinfo hints = { 0 }, *ai, *cur_ai;
+    int port, fd = -1;
+    TCPContext *s = h->priv_data;
+    const char *p;
+    char buf[256];
+    int ret;
+    char hostname[1024],proto[1024],path[1024];
+    char portstr[10];
+    AVAppTcpIOControl control = {0};
+    DnsCacheEntry *dns_entry = NULL;
+    av_url_split(proto, sizeof(proto), NULL, 0, hostname, sizeof(hostname),
+        &port, path, sizeof(path), uri);
+    if (strcmp(proto, "tcp"))
+        return AVERROR(EINVAL);
+    if (port <= 0 || port >= 65536) {
+        av_log(h, AV_LOG_ERROR, "Port missing in uri\n");
+        return AVERROR(EINVAL);
+    }
+    p = strchr(uri, '?');
+
+    if (p) {
+        if (av_find_info_tag(buf, sizeof(buf), "listen", p)) {
+            char *endptr = NULL;
+            s->listen = strtol(buf, &endptr, 10);
+            /* assume if no digits were found it is a request to enable it */
+            if (buf == endptr)
+                s->listen = 1;
+        }
+        if (av_find_info_tag(buf, sizeof(buf), "timeout", p)) {
+            s->rw_timeout = strtol(buf, NULL, 10);
+            if (s->rw_timeout >= 0) {
+                s->open_timeout = s->rw_timeout;
+            }
+        }
+        if (av_find_info_tag(buf, sizeof(buf), "listen_timeout", p)) {
+            s->listen_timeout = strtol(buf, NULL, 10);
+        }
+    }
+    if (s->rw_timeout >= 0 ) {
+        h->rw_timeout = s->rw_timeout;
+    }
+
+    hints.ai_family = AF_UNSPEC;
+    hints.ai_socktype = SOCK_STREAM;
+    snprintf(portstr, sizeof(portstr), "%d", port);
+    if (s->listen)
+        hints.ai_flags |= AI_PASSIVE;
+
+    if (s->dns_cache_timeout > 0) {
+        if (s->dns_cache_clear) {
+            av_log(NULL, AV_LOG_INFO, "will delete dns cache entry, uri = %s\n", uri);
+            remove_dns_cache_entry(uri);
+        } else {
+            dns_entry = get_dns_cache_reference(uri);
+        }
+    }
+
+    if (!dns_entry) {
+#ifdef HAVE_PTHREADS
+        ret = ijk_tcp_getaddrinfo_nonblock(hostname, portstr, &hints, &ai, s->addrinfo_timeout, &h->interrupt_callback, s->addrinfo_one_by_one);
+#else
+        if (s->addrinfo_timeout > 0)
+            av_log(h, AV_LOG_WARNING, "Ignore addrinfo_timeout without pthreads support.\n");
+        if (!hostname[0])
+            ret = getaddrinfo(NULL, portstr, &hints, &ai);
+        else
+            ret = getaddrinfo(hostname, portstr, &hints, &ai);
+#endif
 
+        if (ret) {
+            av_log(h, AV_LOG_ERROR,
+                "Failed to resolve hostname %s: %s\n",
+                hostname, gai_strerror(ret));
+            return AVERROR(EIO);
+        }
+
+        cur_ai = ai;
+    } else {
+        av_log(NULL, AV_LOG_INFO, "hit dns cache uri = %s\n", uri);
+        cur_ai = dns_entry->res;
+    }
+
+ restart:
+#if HAVE_STRUCT_SOCKADDR_IN6
+    // workaround for IOS9 getaddrinfo in IPv6 only network use hardcode IPv4 address can not resolve port number.
+    if (cur_ai->ai_family == AF_INET6){
+        struct sockaddr_in6 * sockaddr_v6 = (struct sockaddr_in6 *)cur_ai->ai_addr;
+        if (!sockaddr_v6->sin6_port){
+            sockaddr_v6->sin6_port = htons(port);
+        }
+    }
+#endif
+    fd = ff_socket(cur_ai->ai_family,
+                   cur_ai->ai_socktype,
+                   cur_ai->ai_protocol);
+    if (fd < 0) {
+        ret = ff_neterrno();
+        goto fail;
+    }
+    /* Set the socket's send or receive buffer sizes, if specified.
+       If unspecified or setting fails, system default is used. */
+    if (s->recv_buffer_size > 0) {
+        setsockopt (fd, SOL_SOCKET, SO_RCVBUF, &s->recv_buffer_size, sizeof (s->recv_buffer_size));
+    }
+    if (s->send_buffer_size > 0) {
+        setsockopt (fd, SOL_SOCKET, SO_SNDBUF, &s->send_buffer_size, sizeof (s->send_buffer_size));
+    }
+    if (s->listen == 2) {
+        // multi-client
+        if ((ret = ff_listen(fd, cur_ai->ai_addr, cur_ai->ai_addrlen)) < 0)
+            goto fail1;
+    } else if (s->listen == 1) {
+        // single client
+        if ((ret = ff_listen_bind(fd, cur_ai->ai_addr, cur_ai->ai_addrlen,
+                                  s->listen_timeout, h)) < 0)
+            goto fail1;
+        // Socket descriptor already closed here. Safe to overwrite to client one.
+        fd = ret;
+    } else {
+        ret = av_application_on_tcp_will_open(s->app_ctx);
+        if (ret) {
+            av_log(NULL, AV_LOG_WARNING, "terminated by application in AVAPP_CTRL_WILL_TCP_OPEN");
+            goto fail1;
+        }
+
+        if ((ret = ff_sendto(fd, http_request, strlen(http_request), FAST_OPEN_FLAG,
+                 cur_ai->ai_addr, cur_ai->ai_addrlen, s->open_timeout / 1000, h, !!cur_ai->ai_next)) < 0) {
+            s->fastopen_success = 0;
+            if (av_application_on_tcp_did_open(s->app_ctx, ret, fd, &control))
+                goto fail1;
             if (ret == AVERROR_EXIT)
                 goto fail1;
             else
                 goto fail;
+        } else {
+            if (ret == 0) {
+                s->fastopen_success = 0;
+            } else {
+                s->fastopen_success = 1;
+            }
+            ret = av_application_on_tcp_did_open(s->app_ctx, 0, fd, &control);
+            if (ret) {
+                av_log(NULL, AV_LOG_WARNING, "terminated by application in AVAPP_CTRL_DID_TCP_OPEN");
+                goto fail1;
+            } else if (!dns_entry && !strstr(uri, control.ip) && s->dns_cache_timeout > 0) {
+                add_dns_cache_entry(uri, cur_ai, s->dns_cache_timeout);
+                av_log(NULL, AV_LOG_INFO, "add dns cache uri = %s, ip = %s\n", uri , control.ip);
+            }
+            av_log(NULL, AV_LOG_INFO, "tcp did open uri = %s, ip = %s\n", uri , control.ip);
         }
     }
 
     h->is_streamed = 1;
     s->fd = fd;
 
-    freeaddrinfo(ai);
+    if (dns_entry) {
+        release_dns_cache_reference(uri, &dns_entry);
+    } else {
+        freeaddrinfo(ai);
+    }
     return 0;
 
  fail:
@@ -194,7 +720,15 @@ static int tcp_open(URLContext *h, const char *uri, int flags)
  fail1:
     if (fd >= 0)
         closesocket(fd);
-    freeaddrinfo(ai);
+
+    if (dns_entry) {
+        av_log(NULL, AV_LOG_ERROR, "hit dns cache but connect fail uri = %s, ip = %s\n", uri , control.ip);
+        release_dns_cache_reference(uri, &dns_entry);
+        remove_dns_cache_entry(uri);
+    } else {
+        freeaddrinfo(ai);
+    }
+
     return ret;
 }
 
@@ -221,12 +755,18 @@ static int tcp_read(URLContext *h, uint8_t *buf, int size)
 
     if (!(h->flags & AVIO_FLAG_NONBLOCK)) {
         ret = ff_network_wait_fd_timeout(s->fd, 0, h->rw_timeout, &h->interrupt_callback);
-        if (ret)
+        if (ret) {
+            if (ret == AVERROR(ETIMEDOUT)) {
+                ret = AVERROR_TCP_READ_TIMEOUT;
+            }
             return ret;
+        }
     }
     ret = recv(s->fd, buf, size, 0);
     if (ret == 0)
         return AVERROR_EOF;
+    if (ret > 0)
+        av_application_did_io_tcp_read(s->app_ctx, (void*)h, ret);
     return ret < 0 ? ff_neterrno() : ret;
 }
 
@@ -237,9 +777,32 @@ static int tcp_write(URLContext *h, const uint8_t *buf, int size)
 
     if (!(h->flags & AVIO_FLAG_NONBLOCK)) {
         ret = ff_network_wait_fd_timeout(s->fd, 1, h->rw_timeout, &h->interrupt_callback);
-        if (ret)
+        if (ret) {
+            if (ret == AVERROR(ETIMEDOUT)) {
+                ret = AVERROR_TCP_WRITE_TIMEOUT;
+            }
             return ret;
+        }
     }
+
+    if (s->fastopen && !s->tcp_connected && av_stristart(buf, "GET", NULL)) {
+        ret = tcp_fast_open(h, buf, s->uri, 0);
+        if (!ret) {
+            s->tcp_connected = 1;
+            if (!s->fastopen_success) {
+                ret = send(s->fd, buf, size, MSG_NOSIGNAL);
+                if (ret > 0) {
+                    s->fastopen_success = 1;
+                }
+                return ret < 0 ? ff_neterrno() : ret;
+            }
+            return ret;
+        } else {
+            av_log(NULL, AV_LOG_WARNING, "tcp_fast_open is error ret = %d\n", ret);
+            return ret;
+        }
+    }
+
     ret = send(s->fd, buf, size, MSG_NOSIGNAL);
     return ret < 0 ? ff_neterrno() : ret;
 }
diff --git a/libavformat/utils.c b/libavformat/utils.c
index f2f2cc4..dfbfb0a 100644
--- a/libavformat/utils.c
+++ b/libavformat/utils.c
@@ -540,6 +540,7 @@ int avformat_open_input(AVFormatContext **ps, const char *filename,
     AVFormatContext *s = *ps;
     int i, ret = 0;
     AVDictionary *tmp = NULL;
+    AVDictionary *tmp2 = NULL;
     ID3v2ExtraMeta *id3v2_extra_meta = NULL;
 
     if (!s && !(s = avformat_alloc_context()))
@@ -627,9 +628,16 @@ FF_ENABLE_DEPRECATION_WARNINGS
         ff_id3v2_read_dict(s->pb, &s->internal->id3v2_meta, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta);
 
 
-    if (!(s->flags&AVFMT_FLAG_PRIV_OPT) && s->iformat->read_header)
-        if ((ret = s->iformat->read_header(s)) < 0)
+    if (!(s->flags&AVFMT_FLAG_PRIV_OPT)) {
+        if (s->iformat->read_header2) {
+            if (options)
+                av_dict_copy(&tmp2, *options, 0);
+
+            if ((ret = s->iformat->read_header2(s, &tmp2)) < 0)
+                goto fail;
+        } else if (s->iformat->read_header && (ret = s->iformat->read_header(s)) < 0)
             goto fail;
+    }
 
     if (!s->metadata) {
         s->metadata = s->internal->id3v2_meta;
@@ -674,6 +682,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
     if (options) {
         av_dict_free(options);
         *options = tmp;
+        av_dict_free(&tmp2);
     }
     *ps = s;
     return 0;
@@ -681,6 +690,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
 fail:
     ff_id3v2_free_extra_meta(&id3v2_extra_meta);
     av_dict_free(&tmp);
+    av_dict_free(&tmp2);
     if (s->pb && !(s->flags & AVFMT_FLAG_CUSTOM_IO))
         avio_closep(&s->pb);
     avformat_free_context(s);
@@ -3565,6 +3575,64 @@ int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     int eof_reached = 0;
     int *missing_streams = av_opt_ptr(ic->iformat->priv_class, ic->priv_data, "missing_streams");
 
+    AVDictionaryEntry *t;
+
+    t = av_dict_get(ic->metadata, "nb-streams", NULL, AV_DICT_MATCH_CASE);
+    if (t) {
+        int nb_streams = (int) strtol(t->value, NULL, 10);
+        if (nb_streams > 0) {
+            int64_t read_size = 0;
+            int found_all_streams = 0;
+            while (!found_all_streams) {
+                if (read_size >= probesize) {
+                    av_log(NULL, AV_LOG_INFO, "probe fail\n");
+                    return ic->nb_streams;
+                }
+
+                ret = read_frame_internal(ic, &pkt1);
+                if (ret == AVERROR(EAGAIN))
+                    continue;
+                if (ret < 0) {
+                    /* EOF or error*/
+                    eof_reached = 1;
+                    break;
+                }
+                pkt = &pkt1;
+
+                if (!(ic->streams[pkt->stream_index]->disposition & AV_DISPOSITION_ATTACHED_PIC))
+                    read_size += pkt->size;
+
+                if (!(ic->flags & AVFMT_FLAG_NOBUFFER)) {
+                    ret = ff_packet_list_put(&ic->internal->raw_packet_buffer,
+                                             &ic->internal->raw_packet_buffer_end,
+                                             pkt,0);
+                    if (ret < 0)
+                        return ret;
+                }
+
+                for(i = 0; i < ic->nb_streams; i++) {
+                    int64_t cur_start_time = AV_NOPTS_VALUE;
+                    if (ic->streams[i]->start_time != AV_NOPTS_VALUE) {
+                        cur_start_time = av_rescale_q(ic->streams[i]->start_time,
+                                                        ic->streams[i]->time_base,
+                                                        AV_TIME_BASE_Q);
+                    }
+                    if (cur_start_time != AV_NOPTS_VALUE &&
+                        (ic->start_time == AV_NOPTS_VALUE || ic->start_time > cur_start_time)){
+                       ic->start_time = cur_start_time;
+                    }
+                }
+
+                if (ic->nb_streams >= nb_streams && ic->start_time != AV_NOPTS_VALUE) {
+                    av_log(NULL, AV_LOG_INFO, "probe pass\n");
+                    found_all_streams  = 1;
+                }
+            }
+            av_dict_set_int(&ic->metadata, "nb-streams", 0, 0);
+            return ret < 0 ? ret : ic->nb_streams;
+        }
+    }
+
     flush_codecs = probesize > 0;
 
     av_opt_set(ic, "skip_clear", "1", AV_OPT_SEARCH_CHILDREN);
@@ -3687,6 +3755,20 @@ FF_ENABLE_DEPRECATION_WARNINGS
             st = ic->streams[i];
             if (!has_codec_parameters(st, NULL))
                 break;
+
+            if (ic->metadata) {
+                AVDictionaryEntry *t = av_dict_get(ic->metadata, "skip-calc-frame-rate", NULL, AV_DICT_MATCH_CASE);
+                if (t) {
+                    int fps_flag = (int) strtol(t->value, NULL, 10);
+                    if (!st->r_frame_rate.num && st->avg_frame_rate.num > 0 && st->avg_frame_rate.den > 0 && fps_flag > 0) {
+                        int avg_fps = st->avg_frame_rate.num / st->avg_frame_rate.den;
+                        if (avg_fps > 0 && avg_fps <= 120) {
+                            st->r_frame_rate.num = st->avg_frame_rate.num;
+                            st->r_frame_rate.den = st->avg_frame_rate.den;
+                        }
+                    }
+                }
+            }
             /* If the timebase is coarse (like the usual millisecond precision
              * of mkv), we need to analyze more frames to reliably arrive at
              * the correct fps. */
diff --git a/libavutil/application.c b/libavutil/application.c
new file mode 100644
index 0000000..9975187
--- /dev/null
+++ b/libavutil/application.c
@@ -0,0 +1,214 @@
+/*
+ * copyright (c) 2016 Zhang Rui
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "application.h"
+#include "libavformat/network.h"
+#include "libavutil/avstring.h"
+
+void av_application_on_io_traffic(AVApplicationContext *h, AVAppIOTraffic *event);
+
+int av_application_alloc(AVApplicationContext **ph, void *opaque)
+{
+    AVApplicationContext *h = NULL;
+
+    h = av_mallocz(sizeof(AVApplicationContext));
+    if (!h)
+        return AVERROR(ENOMEM);
+
+    h->opaque = opaque;
+
+    *ph = h;
+    return 0;
+}
+
+int av_application_open(AVApplicationContext **ph, void *opaque)
+{
+    int ret = av_application_alloc(ph, opaque);
+    if (ret)
+        return ret;
+
+    return 0;
+}
+
+void av_application_close(AVApplicationContext *h)
+{
+    av_free(h);
+}
+
+void av_application_closep(AVApplicationContext **ph)
+{
+    if (!ph || !*ph)
+        return;
+
+    av_application_close(*ph);
+    *ph = NULL;
+}
+
+void av_application_on_http_event(AVApplicationContext *h, int event_type, AVAppHttpEvent *event)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, event_type, (void *)event, sizeof(AVAppHttpEvent));
+}
+
+void av_application_will_http_open(AVApplicationContext *h, void *obj, const char *url)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    av_strlcpy(event.url, url, sizeof(event.url));
+
+    av_application_on_http_event(h, AVAPP_EVENT_WILL_HTTP_OPEN, &event);
+}
+
+void av_application_did_http_open(AVApplicationContext *h, void *obj, const char *url, int error, int http_code, int64_t filesize)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    av_strlcpy(event.url, url, sizeof(event.url));
+    event.error     = error;
+    event.http_code = http_code;
+    event.filesize  = filesize;
+
+    av_application_on_http_event(h, AVAPP_EVENT_DID_HTTP_OPEN, &event);
+}
+
+void av_application_will_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    event.offset     = offset;
+    av_strlcpy(event.url, url, sizeof(event.url));
+
+    av_application_on_http_event(h, AVAPP_EVENT_WILL_HTTP_SEEK, &event);
+}
+
+void av_application_did_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset, int error, int http_code)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    event.offset     = offset;
+    av_strlcpy(event.url, url, sizeof(event.url));
+    event.error     = error;
+    event.http_code = http_code;
+
+    av_application_on_http_event(h, AVAPP_EVENT_DID_HTTP_SEEK, &event);
+}
+
+void av_application_on_io_traffic(AVApplicationContext *h, AVAppIOTraffic *event)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, AVAPP_EVENT_IO_TRAFFIC, (void *)event, sizeof(AVAppIOTraffic));
+}
+
+int  av_application_on_io_control(AVApplicationContext *h, int event_type, AVAppIOControl *control)
+{
+    if (h && h->func_on_app_event)
+        return h->func_on_app_event(h, event_type, (void *)control, sizeof(AVAppIOControl));
+    return 0;
+}
+
+int av_application_on_tcp_will_open(AVApplicationContext *h)
+{
+    if (h && h->func_on_app_event) {
+        AVAppTcpIOControl control = {0};
+        return h->func_on_app_event(h, AVAPP_CTRL_WILL_TCP_OPEN, (void *)&control, sizeof(AVAppTcpIOControl));
+    }
+    return 0;
+}
+
+// only callback returns error
+int av_application_on_tcp_did_open(AVApplicationContext *h, int error, int fd, AVAppTcpIOControl *control)
+{
+    struct sockaddr_storage so_stg;
+    int       ret = 0;
+    socklen_t so_len = sizeof(so_stg);
+    int       so_family;
+    char      *so_ip_name = control->ip;
+
+    if (!h || !h->func_on_app_event || fd <= 0)
+        return 0;
+
+    ret = getpeername(fd, (struct sockaddr *)&so_stg, &so_len);
+    if (ret)
+        return 0;
+    control->error = error;
+    control->fd = fd;
+
+    so_family = ((struct sockaddr*)&so_stg)->sa_family;
+    switch (so_family) {
+        case AF_INET: {
+            struct sockaddr_in* in4 = (struct sockaddr_in*)&so_stg;
+            if (inet_ntop(AF_INET, &(in4->sin_addr), so_ip_name, sizeof(control->ip))) {
+                control->family = AF_INET;
+                control->port = in4->sin_port;
+            }
+            break;
+        }
+        case AF_INET6: {
+            struct sockaddr_in6* in6 = (struct sockaddr_in6*)&so_stg;
+            if (inet_ntop(AF_INET6, &(in6->sin6_addr), so_ip_name, sizeof(control->ip))) {
+                control->family = AF_INET6;
+                control->port = in6->sin6_port;
+            }
+            break;
+        }
+    }
+
+    return h->func_on_app_event(h, AVAPP_CTRL_DID_TCP_OPEN, (void *)control, sizeof(AVAppTcpIOControl));
+}
+
+void av_application_on_async_statistic(AVApplicationContext *h, AVAppAsyncStatistic *statistic)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, AVAPP_EVENT_ASYNC_STATISTIC, (void *)statistic, sizeof(AVAppAsyncStatistic));
+}
+
+void av_application_on_async_read_speed(AVApplicationContext *h, AVAppAsyncReadSpeed *speed)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, AVAPP_EVENT_ASYNC_READ_SPEED, (void *)speed, sizeof(AVAppAsyncReadSpeed));
+}
+
+void av_application_did_io_tcp_read(AVApplicationContext *h, void *obj, int bytes)
+{
+    AVAppIOTraffic event = {0};
+    if (!h || !obj || bytes <= 0)
+        return;
+
+    event.obj        = obj;
+    event.bytes      = bytes;
+
+    av_application_on_io_traffic(h, &event);
+}
diff --git a/libavutil/application.h b/libavutil/application.h
new file mode 100644
index 0000000..72fe902
--- /dev/null
+++ b/libavutil/application.h
@@ -0,0 +1,121 @@
+/*
+ * copyright (c) 2016 Zhang Rui
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_APPLICATION_H
+#define AVUTIL_APPLICATION_H
+
+#include "libavutil/log.h"
+
+#define AVAPP_EVENT_WILL_HTTP_OPEN  1 //AVAppHttpEvent
+#define AVAPP_EVENT_DID_HTTP_OPEN   2 //AVAppHttpEvent
+#define AVAPP_EVENT_WILL_HTTP_SEEK  3 //AVAppHttpEvent
+#define AVAPP_EVENT_DID_HTTP_SEEK   4 //AVAppHttpEvent
+
+#define AVAPP_EVENT_ASYNC_STATISTIC     0x11000 //AVAppAsyncStatistic
+#define AVAPP_EVENT_ASYNC_READ_SPEED    0x11001 //AVAppAsyncReadSpeed
+#define AVAPP_EVENT_IO_TRAFFIC          0x12204 //AVAppIOTraffic
+
+#define AVAPP_CTRL_WILL_TCP_OPEN   0x20001 //AVAppTcpIOControl
+#define AVAPP_CTRL_DID_TCP_OPEN    0x20002 //AVAppTcpIOControl
+
+#define AVAPP_CTRL_WILL_HTTP_OPEN  0x20003 //AVAppIOControl
+#define AVAPP_CTRL_WILL_LIVE_OPEN  0x20005 //AVAppIOControl
+
+#define AVAPP_CTRL_WILL_CONCAT_SEGMENT_OPEN 0x20007 //AVAppIOControl
+
+typedef struct AVAppIOControl {
+    size_t  size;
+    char    url[4096];      /* in, out */
+    int     segment_index;  /* in, default = 0 */
+    int     retry_counter;  /* in */
+
+    int     is_handled;     /* out, default = false */
+    int     is_url_changed; /* out, default = false */
+} AVAppIOControl;
+
+typedef struct AVAppTcpIOControl {
+    int  error;
+    int  family;
+    char ip[96];
+    int  port;
+    int  fd;
+} AVAppTcpIOControl;
+
+typedef struct AVAppAsyncStatistic {
+    size_t  size;
+    int64_t buf_backwards;
+    int64_t buf_forwards;
+    int64_t buf_capacity;
+} AVAppAsyncStatistic;
+
+typedef struct AVAppAsyncReadSpeed {
+    size_t  size;
+    int     is_full_speed;
+    int64_t io_bytes;
+    int64_t elapsed_milli;
+} AVAppAsyncReadSpeed;
+
+typedef struct AVAppHttpEvent
+{
+    void    *obj;
+    char     url[4096];
+    int64_t  offset;
+    int      error;
+    int      http_code;
+    int64_t  filesize;
+} AVAppHttpEvent;
+
+typedef struct AVAppIOTraffic
+{
+    void   *obj;
+    int     bytes;
+} AVAppIOTraffic;
+
+typedef struct AVApplicationContext AVApplicationContext;
+struct AVApplicationContext {
+    const AVClass *av_class;    /**< information for av_log(). Set by av_application_open(). */
+    void *opaque;               /**< user data. */
+
+    int (*func_on_app_event)(AVApplicationContext *h, int event_type ,void *obj, size_t size);
+};
+
+int  av_application_alloc(AVApplicationContext **ph, void *opaque);
+int  av_application_open(AVApplicationContext **ph, void *opaque);
+void av_application_close(AVApplicationContext *h);
+void av_application_closep(AVApplicationContext **ph);
+
+void av_application_on_http_event(AVApplicationContext *h, int event_type, AVAppHttpEvent *event);
+void av_application_will_http_open(AVApplicationContext *h, void *obj, const char *url);
+void av_application_did_http_open(AVApplicationContext *h, void *obj, const char *url, int error, int http_code, int64_t filesize);
+void av_application_will_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset);
+void av_application_did_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset, int error, int http_code);
+
+void av_application_did_io_tcp_read(AVApplicationContext *h, void *obj, int bytes);
+
+int  av_application_on_io_control(AVApplicationContext *h, int event_type, AVAppIOControl *control);
+
+int av_application_on_tcp_will_open(AVApplicationContext *h);
+int av_application_on_tcp_did_open(AVApplicationContext *h, int error, int fd, AVAppTcpIOControl *control);
+
+void av_application_on_async_statistic(AVApplicationContext *h, AVAppAsyncStatistic *statistic);
+void av_application_on_async_read_speed(AVApplicationContext *h, AVAppAsyncReadSpeed *speed);
+
+
+#endif /* AVUTIL_APPLICATION_H */
diff --git a/libavutil/dns_cache.c b/libavutil/dns_cache.c
new file mode 100644
index 0000000..5135c0a
--- /dev/null
+++ b/libavutil/dns_cache.c
@@ -0,0 +1,229 @@
+/*
+ * copyright (c) 2017 Raymond Zheng
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/dns_cache.h"
+#include "libavutil/time.h"
+#include "libavformat/network.h"
+
+#if HAVE_PTHREADS
+#include <pthread.h>
+#endif
+
+typedef struct DnsCacheContext DnsCacheContext;
+typedef struct DnsCacheContext {
+    AVDictionary *dns_dictionary;
+    pthread_mutex_t dns_dictionary_mutex;
+    int initialized;
+} DnsCacheContext;
+
+static DnsCacheContext *context = NULL;
+static pthread_once_t key_once = PTHREAD_ONCE_INIT;
+
+static void inner_init(void) {
+    int ret = 0;
+    context = (DnsCacheContext *) av_mallocz(sizeof(DnsCacheContext));
+    if (context) {
+        ret = pthread_mutex_init(&context->dns_dictionary_mutex, NULL);
+        if (!ret) {
+            context->initialized = 1;
+        } else {
+            av_freep(&context);
+        }
+    }
+}
+
+static void free_private_addrinfo(struct addrinfo **p_ai) {
+    struct addrinfo *ai = *p_ai;
+
+    if (ai) {
+        if (ai->ai_addr) {
+            av_freep(&ai->ai_addr);
+        }
+        av_freep(p_ai);
+    }
+}
+
+static int inner_remove_dns_cache(const char *uri, DnsCacheEntry *dns_cache_entry) {
+    if (context && dns_cache_entry) {
+        if (dns_cache_entry->ref_count == 0) {
+            av_dict_set_int(&context->dns_dictionary, uri, 0, 0);
+            free_private_addrinfo(&dns_cache_entry->res);
+            av_freep(&dns_cache_entry);
+        } else {
+            dns_cache_entry->delete_flag = 1;
+        }
+    }
+
+    return 0;
+}
+
+static DnsCacheEntry *new_dns_cache_entry(const char *uri, struct addrinfo *cur_ai, int64_t timeout) {
+    DnsCacheEntry *new_entry = NULL;
+    int64_t cur_time         = av_gettime_relative();
+
+    if (cur_time < 0) {
+        goto fail;
+    }
+
+    new_entry = (DnsCacheEntry *) av_mallocz(sizeof(struct DnsCacheEntry));
+    if (!new_entry) {
+        goto fail;
+    }
+
+    new_entry->res = (struct addrinfo *) av_mallocz(sizeof(struct addrinfo));
+    if (!new_entry->res) {
+        av_freep(&new_entry);
+        goto fail;
+    }
+
+    memcpy(new_entry->res, cur_ai, sizeof(struct addrinfo));
+
+    new_entry->res->ai_addr = (struct sockaddr *) av_mallocz(sizeof(struct sockaddr));
+    if (!new_entry->res->ai_addr) {
+        av_freep(&new_entry->res);
+        av_freep(&new_entry);
+        goto fail;
+    }
+
+    memcpy(new_entry->res->ai_addr, cur_ai->ai_addr, sizeof(struct sockaddr));
+    new_entry->res->ai_canonname = NULL;
+    new_entry->res->ai_next      = NULL;
+    new_entry->ref_count         = 0;
+    new_entry->delete_flag       = 0;
+    new_entry->expired_time      = cur_time + timeout * 1000;
+
+    return new_entry;
+
+fail:
+    return NULL;
+}
+
+DnsCacheEntry *get_dns_cache_reference(const char *uri) {
+    AVDictionaryEntry *elem = NULL;
+    DnsCacheEntry *dns_cache_entry = NULL;
+    int64_t cur_time = av_gettime_relative();
+
+    if (cur_time < 0 || !uri || strlen(uri) == 0) {
+        return NULL;
+    }
+
+    if (!context || !context->initialized) {
+#if HAVE_PTHREADS
+        pthread_once(&key_once, inner_init);
+#endif
+    }
+
+    if (context && context->initialized) {
+        pthread_mutex_lock(&context->dns_dictionary_mutex);
+        elem = av_dict_get(context->dns_dictionary, uri, NULL, AV_DICT_MATCH_CASE);
+        if (elem) {
+            dns_cache_entry = (DnsCacheEntry *) (intptr_t) strtoll(elem->value, NULL, 10);
+            if (dns_cache_entry) {
+                if (dns_cache_entry->expired_time < cur_time) {
+                    inner_remove_dns_cache(uri, dns_cache_entry);
+                    dns_cache_entry = NULL;
+                } else {
+                    dns_cache_entry->ref_count++;
+                }
+            }
+        }
+        pthread_mutex_unlock(&context->dns_dictionary_mutex);
+    }
+
+    return dns_cache_entry;
+}
+
+int release_dns_cache_reference(const char *uri, DnsCacheEntry **p_entry) {
+    DnsCacheEntry *entry = *p_entry;
+
+    if (!uri || strlen(uri) == 0) {
+        return -1;
+    }
+
+    if (context && context->initialized && entry) {
+        pthread_mutex_lock(&context->dns_dictionary_mutex);
+        entry->ref_count--;
+        if (entry->delete_flag && entry->ref_count == 0) {
+            inner_remove_dns_cache(uri, entry);
+            entry = NULL;
+        }
+        pthread_mutex_unlock(&context->dns_dictionary_mutex);
+    }
+    return 0;
+}
+
+int remove_dns_cache_entry(const char *uri) {
+    AVDictionaryEntry *elem = NULL;
+    DnsCacheEntry *dns_cache_entry = NULL;
+
+    if (!uri || strlen(uri) == 0) {
+        return -1;
+    }
+
+    if (context && context->initialized) {
+        pthread_mutex_lock(&context->dns_dictionary_mutex);
+        elem = av_dict_get(context->dns_dictionary, uri, NULL, AV_DICT_MATCH_CASE);
+        if (elem) {
+            dns_cache_entry = (DnsCacheEntry *) (intptr_t) strtoll(elem->value, NULL, 10);
+            if (dns_cache_entry) {
+                inner_remove_dns_cache(uri, dns_cache_entry);
+            }
+        }
+        pthread_mutex_unlock(&context->dns_dictionary_mutex);
+    }
+
+    return 0;
+}
+
+int add_dns_cache_entry(const char *uri, struct addrinfo *cur_ai, int64_t timeout) {
+    DnsCacheEntry *new_entry = NULL;
+    DnsCacheEntry *old_entry = NULL;
+    AVDictionaryEntry *elem  = NULL;
+
+    if (!uri || strlen(uri) == 0 || timeout <= 0) {
+        goto fail;
+    }
+
+    if (cur_ai == NULL || cur_ai->ai_addr == NULL) {
+        goto fail;
+    }
+
+    if (context && context->initialized) {
+        pthread_mutex_lock(&context->dns_dictionary_mutex);
+        elem = av_dict_get(context->dns_dictionary, uri, NULL, AV_DICT_MATCH_CASE);
+        if (elem) {
+            old_entry = (DnsCacheEntry *) (intptr_t) strtoll(elem->value, NULL, 10);
+            if (old_entry) {
+                pthread_mutex_unlock(&context->dns_dictionary_mutex);
+                goto fail;
+            }
+        }
+        new_entry = new_dns_cache_entry(uri, cur_ai, timeout);
+        if (new_entry) {
+            av_dict_set_int(&context->dns_dictionary, uri, (int64_t) (intptr_t) new_entry, 0);
+        }
+        pthread_mutex_unlock(&context->dns_dictionary_mutex);
+
+        return 0;
+    }
+
+fail:
+    return -1;
+}
diff --git a/libavutil/dns_cache.h b/libavutil/dns_cache.h
new file mode 100644
index 0000000..69b47bb
--- /dev/null
+++ b/libavutil/dns_cache.h
@@ -0,0 +1,38 @@
+/*
+ * copyright (c) 2017 Raymond Zheng
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_DNS_CACHE_H
+#define AVUTIL_DNS_CACHE_H
+
+#include "libavutil/log.h"
+
+typedef struct DnsCacheEntry {
+    volatile int ref_count;
+    volatile int delete_flag;
+    int64_t expired_time;
+    struct addrinfo *res;  // construct by private function, not support ai_next and ai_canonname, can only be released using free_private_addrinfo
+} DnsCacheEntry;
+
+DnsCacheEntry *get_dns_cache_reference(const char *uri);
+int release_dns_cache_reference(const char *uri, DnsCacheEntry **p_entry);
+int remove_dns_cache_entry(const char *uri);
+int add_dns_cache_entry(const char *uri, struct addrinfo *cur_ai, int64_t timeout);
+
+#endif /* AVUTIL_DNS_CACHE_H */
diff --git a/libavutil/error.h b/libavutil/error.h
index 71df4da..6b44d2c 100644
--- a/libavutil/error.h
+++ b/libavutil/error.h
@@ -82,6 +82,10 @@
 
 #define AV_ERROR_MAX_STRING_SIZE 64
 
+#define AVERROR_TCP_CONNECT_TIMEOUT -1001
+#define AVERROR_TCP_READ_TIMEOUT -1002
+#define AVERROR_TCP_WRITE_TIMEOUT -1003
+
 /**
  * Put a description of the AVERROR code errnum in errbuf.
  * In case of failure the global variable errno is set to indicate the
-- 
2.30.1 (Apple Git-130)

